' in this file, we define how the generate process creates the .ODN file for the graphics
' a line prefixed by "'" is a comment for this file
' otherwise the line is written out as is unless special processing is performed, designated by {processname}
' 
'
' Memory Map
'
' start   length
' $4000   $1800  - Standard ULA screen
' $5800   $0300  - ULA attributes
' $5B00 
'
' $6000   $0500  - Tilemap           (40 * 32 bytes i.e. 1 byte mode)
' $6500   $7500  - tiles             (128 * 32 bytes)
' $7500   $0200  - tilemap palette 0 (256 * 2 bytes)
' $7700   $4000  - Sprites           (63 * 256 bytes 16k!)
' $B700   $0200  - sprite palette 0  (256 * 2 bytes)
' 
' $B900. 
' 
' - screen data
' - code to setup Sprites/Tiles/Tilemap
' - program code
'
' $FFFF.  
'
'
' Puts device ZXSPECTRUMNEXT
{ZXSPECTRUMNEXT}
'
' ORG definition, must have start address and must be in hex (4 digits)
{ORG} $6000

; Tilemap definition
; defines what tiles go where in the 40x32 grid
; currently 1 byte tilemap mode only
tileMapData:
DEFS 1280, 0

{TILEPATTERNS}
' TilePaterns:
' db $nn, $nn, $nn ... $nn
' ...
' db $nn, $nn, $nn, ... $nn

{SPRITEPATTERNS}
' SpritePatterns:
' db $nn, $nn, $nn ... $nn
' ...
' db $nn, $nn, $nn, ... $nn

{PAGEDATA}

{TILEPALETTE}
' TilePalette0:
' DB $nn, $nn, ... $nn, $nn
' ...
' DB $nn, $nn, ... $nn, $nn
' TilePalette0Len EQU ($ - TilePalette0) / 2

{SPRITEPALETTE}
' SpritePalette0:
' DB $nn, $nn, ... $nn, $nn
' ...
' DB $nn, $nn, ... $nn, $nn
' SpritePalette0Len EQU ($ - SpritePalette0) / 2
'

; *****************************************
; call to initialise the graphics
; *****************************************
spriteSetup:

; Configure tilemap control
 NEXTREG $6b, %10100001
; bit 7 1= enable tilemap
; bit 6 1= 80x32, 0=40x32
; bit 5 1= use 6c for attributes (i.e. 1 byte tilemap mode)
; bit 4 1= 2nd tilemap palette, 0= first
; bit 3 1= activate text mode
; bit 2 reserved, set to 0
; bit 1 1=512, 0=256 tilemap mode
; bit 0 1= force tilemap ontop of ULA

; Default tilemap attribute for 8bit maps
; i.e. when using 1 byte tilemap mode
; NB limits colours to 0-15
 NEXTREG $6c, $0
; bit 7-4 Palette offset
; bit 3 1=mirror in X direction
; bit 2 1=mirror in Y direction
; bit 1 1=rotate 90deg clockwise
; bit 0 1=ula overtilemap, 0=tilemap over ULA
 
; ULA control
  NEXTREG $68, $0
; bit 7 1=disable ULA output
; bit 6 concerned with blending in SLU modes 6/7
;       1=select ULA/tilemap mix
;       0=select ULA colour
; bits 5-1 reserved, always 0
; bit 0 1=enable stencil mode when ULA & tilemap enabled
 
; point to the tilemap and tile pattern data
  NEXTREG $6e, tileMapData / 256
  NEXTREG $6f, TilePatterns / 256
 
; Palette Control
; set values for Tilemap palette 0
  NEXTREG $43, %00110000
; bit 7 1=disable palette auto inc
; bit 6-4 select palette for r/w
; 000 = ULA palette 1
; 100 = ULA palette 2
; 001 = Layer 2 palette 1
; 101 = Layer 2 palette 2
; 010 = Sprites palette 1
; 110 = Sprites palette 2
; 011 = Tilemap palette 1
; 111 = Tilemap palette 2
; bit 3
; bit 2
; bit 1
; bit 0

; Set index of transparent colour in Tilemap palette
  NEXTREG $4c, 0
 
; load the colours into the palette memory
; here we are using 9 bit colours, so use $44 to do the load

; first initialise the palette index to 0
  NEXTREG $40, 0

; set the number of colours 
; set location of Tilemap palette data
  LD B, TilePalette0Len
  LD HL, TilePalette0

; write palette data, 2 bytes per colour
tilemapPalette0Loop:
  LD A, (HL)
  INC HL
  NEXTREG $44, A
  LD A, (HL)
  INC HL
  NEXTREG $44, A
  DJNZ tilemapPalette0Loop
 
; Configure Sprite and Layers System
  NEXTREG $15, %00000011
; bit 7 1=enable lo-res 
; bit 6 1=flip sprite rendering priority
; bit 5 1=change clipping over border mode
; bit 4-2 000=sprites on top, layer 2 under
; bit 1 1=enable sprites over border
; bit 0 1=enable sprite visibility
 
  LD BC, $303b                 ; set port for Sprites
  SUB A, A                     ; Set sprite index to 0
  OUT (C), A                   ; write to port

 LD HL, SpritePatterns; point to sprite patterns
 LD BC, $5b                    ; set port to write patterns to
 LD DE, endofSprites - SpritePatterns

spritePatternLoop:
 LD A, (HL)                    ; get each byte of pattern data
 INC HL                        ; ready for next read
 OUT (C), A                    ; upload to sprite memory
 DEC DE                        ; dec loop count
 LD A, E                       ; test for 0
 OR A, D
 JR NZ, spritePatternLoop      ; loop if more data

; Palette Control
; set values for Sprites palette 1
 NEXTREG $43, %00100000
; bit 7 1=disable palette auto inc
; bit 6-4 select palette for r/w
; 000 = ULA palette 1
; 100 = ULA palette 2
; 001 = Layer 2 palette 1
; 101 = Layer 2 palette 2
; 010 = Sprites palette 1
; 110 = Sprites palette 2
; 011 = Tilemap palette 1
; 111 = Tilemap palette 2
; bit 3
; bit 2
; bit 1
; bit 0

; set index of transparent colour in the Sprite palette
 NEXTREG $4b, 0

; load the colours into the palette memory
; here we are using 9 bit colours, so use $44 to do the load

; first initialise the palette index to 0
 NEXTREG $40, 0

; set the number of colours 
; set location of sprite palette data
 LD B, SpritePalette0Len
 LD HL, SpritePalette0

; write palette data, 2 bytes per colour
spritePalette0Loop:
 LD A, (HL)
 INC HL
 NEXTREG $44, A
 LD A, (HL)
 INC HL
 NEXTREG $44, A
 DJNZ spritePalette0Loop
 RET

